"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ODataMetadata = void 0;
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
/**
 *
 */
class ODataMetadata {
    constructor(metadata, parserMetadata, metadataUrl, edmx, ETag) {
        this.edmx = edmx;
        this.typeToEntityMapping = {};
        this.metadata = metadata;
        this.parserMetadata = parserMetadata;
        this.metadataUrl = metadataUrl;
        this.ETag = ETag;
    }
    static async parse(edmx, metadataUrl, ETag) {
        const metadata = (0, edmx_parser_1.parse)(edmx);
        const converterMetadata = (0, annotation_converter_1.convert)(metadata);
        return new ODataMetadata(converterMetadata, metadata, metadataUrl, edmx, ETag);
    }
    getEdmx() {
        return this.edmx;
    }
    getMetadataUrl() {
        return this.metadataUrl;
    }
    getVersion() {
        return this.metadata.version === '1.0' ? '2.0' : '4.0';
    }
    getEntitySet(entitySetName) {
        return this.metadata.entitySets.find((entitySet) => entitySet.name === entitySetName);
    }
    getSingleton(singletonName) {
        return this.metadata.singletons.find((singleton) => singleton.name === singletonName);
    }
    getEntitySets() {
        return this.metadata.entitySets;
    }
    getSingletons() {
        return this.metadata.singletons || [];
    }
    getEntityType(entityTypeName) {
        return this.metadata.entityTypes.find((entityType) => entityType.name === entityTypeName);
    }
    getEntitySetByType(entityTypeName) {
        return this.metadata.entitySets.find((entitySet) => entitySet.entityTypeName === entityTypeName);
    }
    getActionByFQN(actionFQN) {
        return this.metadata.actions.find((action) => action.fullyQualifiedName === actionFQN);
    }
    getActionImportByFQN(actionImportFQN) {
        return this.metadata.actionImports.find((actionImport) => actionImport.fullyQualifiedName === actionImportFQN);
    }
    getEntityContainerPath() {
        return this.parserMetadata.schema.entityContainer.fullyQualifiedName;
    }
    isDraftEntity(entitySet) {
        var _a, _b, _c, _d;
        return (((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftRoot) !== undefined ||
            ((_d = (_c = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _c === void 0 ? void 0 : _c.Common) === null || _d === void 0 ? void 0 : _d.DraftNode) !== undefined);
    }
    isStickyEntity(entitySet) {
        var _a, _b;
        return ((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Session) === null || _b === void 0 ? void 0 : _b.StickySessionSupported) !== undefined;
    }
    isDraftRoot(entitySet) {
        var _a, _b;
        return ((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftRoot) !== undefined;
    }
    resolvePath(path) {
        return this.metadata.resolvePath(path);
    }
    findInDescendant(entitySet, targetEntitySet, path) {
        // Check if we are a descendent
        let found = false;
        Object.keys(entitySet.navigationPropertyBinding).forEach((navName) => {
            const subET = entitySet.navigationPropertyBinding[navName];
            const navInvolved = entitySet.entityType.navigationProperties.find((nav) => nav.name === navName);
            let partnerNav;
            if (navInvolved === null || navInvolved === void 0 ? void 0 : navInvolved.partner) {
                partnerNav = navInvolved.targetType.navigationProperties.find((nav) => nav.name === navInvolved.partner);
            }
            if (subET === targetEntitySet && navInvolved) {
                found = true;
                path.push({
                    name: navName,
                    entitySet: subET,
                    navigation: navInvolved,
                    partner: partnerNav
                });
            }
        });
        if (!found) {
            // Look into children
            Object.keys(entitySet.navigationPropertyBinding).forEach((navName) => {
                const subET = entitySet.navigationPropertyBinding[navName];
                const navInvolved = entitySet.entityType.navigationProperties.find((nav) => nav.name === navName);
                let partnerNav;
                if (navInvolved === null || navInvolved === void 0 ? void 0 : navInvolved.partner) {
                    partnerNav = navInvolved.targetType.navigationProperties.find((nav) => nav.name === navInvolved.partner);
                    const subPath = path.concat([
                        {
                            name: navName,
                            entitySet: subET,
                            navigation: navInvolved,
                            partner: partnerNav
                        }
                    ]);
                    if (this.findInDescendant(subET, targetEntitySet, subPath)) {
                        // found it in descendent
                        found = true;
                        subPath.slice(path.length).forEach((subPathPart) => {
                            path.push(subPathPart);
                        });
                    }
                }
            });
        }
        return found;
    }
    resolveDraftRoot(entitySet) {
        let found = false;
        let foundPath;
        let rootEntitySet;
        this.metadata.entitySets.forEach((et) => {
            if (this.isDraftRoot(et) && !found) {
                const resolvePath = [];
                found = this.findInDescendant(et, entitySet, resolvePath);
                if (found) {
                    foundPath = resolvePath.concat();
                    rootEntitySet = et;
                }
            }
        });
        return {
            found,
            entitySet: rootEntitySet,
            path: foundPath
        };
    }
    resolveAncestors(entitySet) {
        let found = false;
        let foundPath;
        let rootEntitySet;
        this.metadata.entitySets.forEach((et) => {
            if (!found) {
                const resolvePath = [];
                found = this.findInDescendant(et, entitySet, resolvePath);
                if (found) {
                    foundPath = resolvePath.concat();
                    rootEntitySet = et;
                }
            }
        });
        return {
            found,
            entitySet: rootEntitySet,
            path: foundPath
        };
    }
    getParentEntitySetName(sourceEntitySet) {
        const { found, path, entitySet } = this.resolveAncestors(sourceEntitySet);
        if (found) {
            if (path.length === 1 && entitySet) {
                return entitySet.name;
            }
            else {
                return path[path.length - 1].entitySet.name;
            }
        }
    }
    getETag() {
        return this.ETag;
    }
    getKeys(dataLine, entityType) {
        const keys = entityType.keys;
        const keyValues = {};
        keys.forEach((keyProp) => {
            keyValues[keyProp.name] = dataLine[keyProp.name];
        });
        return keyValues;
    }
}
exports.ODataMetadata = ODataMetadata;
//# sourceMappingURL=metadata.js.map